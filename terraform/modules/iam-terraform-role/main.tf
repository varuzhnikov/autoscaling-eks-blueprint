# ------------------------------------------------------------
# Trust policy for Terraform execution role
#
# IMPORTANT:
# This role is NOT assumed directly by IAM users.
# It is assumed by AWS IAM Identity Center (SSO) generated roles.
#
# When a user is assigned to an AWS account via:
#   IAM Identity Center → Group → Permission Set → Account
#
# AWS automatically creates an IAM role in the target account:
#   arn:aws:iam::<account-id>:role/aws-reserved/sso.amazonaws.com/
#     AWSReservedSSO_<PermissionSetName>_<random-suffix>
#
# The exact role name is generated by AWS and MUST NOT be hardcoded.
# Therefore, we trust all SSO-generated roles in this account by using
# the aws-reserved/sso.amazonaws.com/* path prefix.
#
# Access control is enforced at two levels:
#   1) IAM Identity Center (who gets an SSO role in this account)
#   2) TerraformExecutionRole IAM policy (what Terraform can do)
#
# This allows:
#   - Centralized user management via SSO
#   - No IAM users or long-lived credentials
#   - Safe onboarding/offboarding without Terraform changes
# ------------------------------------------------------------
data "aws_iam_policy_document" "trust" {
  statement {
    sid    = "AllowTerraformRole"
    effect = "Allow"
    
    principals {
      type = "AWS"
      identifiers = var.trusted_role_arns
    }
    
    actions = ["sts:AssumeRole"]
  }
}

resource "aws_iam_role" "this" {
  name               = var.role_name
  assume_role_policy = data.aws_iam_policy_document.trust.json
  
  tags = {
    Purpose = "terraform-execution"
  }
}

data "aws_iam_policy_document" "permissions" {
  
  # Terraform state access (S3 backend)
  statement {
    sid    = "TerraformStateS3Access"
    effect = "Allow"
    
    actions = [
      "s3:GetObject",
      "s3:PutObject",
      "s3:DeleteObject",
      "s3:ListBucket"
    ]
    
    resources = [
      var.state_bucket_arn,
      "${var.state_bucket_arn}/*"
    ]
  }

  # Terraform state locking (dynamodb)
  statement {
    sid = "TerraformStateLocking"
    effect = "Allow"

    actions = [
      "dynamodb:GetItem",
      "dynamodb:PutItem",
      "dynamodb:DeleteItem",
      "dynamodb:UpdateItem"
    ]

    resources = [
      var.lock_table_arn
    ]
  }

  # VPC management
  #statement {
  #  sid    = "VpcManagement"
  #  effect = "Allow"

  #  actions = [
  #    "ec2:CreateVpc",
  #    "ec2:DeleteVpc",
  #    "ec2:DescribeVpc",
      
  #    "ec2:CreateSubnet",
  #    "ec2:DeleteSubnet",
  #    "ec2:DescribeSubnets",

  #    "ec2:CreateInternetGateway",
  #    "ec2:AttachInternetGateway",
  #    "ec2:DetachInternetGateway",
  #    "ec2:DeleteInternetGateway",

  #    "ec2:CreateRouteTable",
  #    "ec2:DeleteRouteTable",
  #    "ec2:CreateRoute",
  #    "ec2:AssociateRouteTable",
  #    "ec2:DisassociateRouteTable",
  #    "ec2:DescribeRouteTables"
  #  ]
    
  #  resources = ["*"]

  #  condition {
  #    test     = "StringEquals"
  #    variable = "aws:RequestedRegion"
  #    values   = [var.aws_region]
  #  }
  #}
}

resource "aws_iam_policy" "this" {
  name   = "${var.role_name}-policy"
  policy = data.aws_iam_policy_document.permissions.json
}

resource "aws_iam_role_policy_attachment" "this" {
  role       = aws_iam_role.this.name
  policy_arn = aws_iam_policy.this.arn
}
